
\section{Deterministic Parity Automata}
\begin{frame}{$\omega$-automata}
$\omega$-words are words of one-sided infinite length: $\alpha \in \Sigma^\omega \Leftrightarrow \alpha : \mathbb{N} \rightarrow \Sigma$ \\
$a^\omega$, $aa(ba)^\omega$, $(abc)^\omega$

\vspace{.5cm}

$\omega$-automata are finite transition structures that describe a language $L(\mathcal{A}) \subseteq \Sigma^\omega$ \\
$\{ a^n b^\omega \mid n \in \mathbb{N} \}$

\vspace{.5cm}

Deterministic parity automata (DPA):
\begin{itemize}
	\item State set $Q$
	\item Alphabet $\Sigma$
	\item Transition function $\delta : Q \times \Sigma \rightarrow Q$
	\item Priority function $c : Q \rightarrow \mathbb{N}$
\end{itemize}

An $\omega$-word $\alpha$ starting in a state $q_0 \in Q$ induces a run $q_0 q_1 q_2 \dots$. The DPA accepts $\alpha$ iff the \emph{smallest} priority that occurs infinitely often in the sequence $c(q_0) c(q_1) c(q_2) \dots$ is \emph{even}.

\end{frame}


\section{Why do we need heuristic reduction?}
\begin{frame}{Why do we need heuristic reduction?}

Goal: Reduce number of states in the automaton to ease run time of follow up algorithms.

\textbf{Minimization Problem}: Given an automaton $\mathcal{A}$, what is the smallest number of states required to recognize the same language as $\mathcal{A}$?

For deterministic finite automata (on finite words): Minimization is solvable in $\mathcal{O}(n \log n)$.

For DPAs: Minimization is NP-hard. \cite{}

\end{frame}


\begin{frame}{Moore Minimization}
A DPA can be interpreted as a Moore automaton with $c$ being the output function.

\begin{theorem}
	Deterministic Moore automata can be minimized in log-linear time.
\end{theorem}

Idea: Compute equivalence $\equiv_M$ with $p \equiv_M q$ iff $\forall w \in \Sigma^*: c(\delta^*(p, w)) = c(\delta^*(q, w))$. Build the quotient automaton w.r.t. $\equiv_M$.

The same algorithm can be used to reduce DPAs but will not give minimal DPAs in general.
\end{frame}




\section{Merger functions as a framework}
\begin{frame}{Merger functions}
\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, \delta, c)$ be a DPA. A \emph{merger function} is a function $\mu : D \rightarrow 2^Q \setminus \{\emptyset\}$ such that 
	\begin{itemize}
		\item all sets in $D$ are pairwise disjoint
		\item for all $X \in D$, $\mu(X) \cap (U \setminus X) = \emptyset$, where $U = \bigcup D$
	\end{itemize}
\end{defn}

$\mu(M) = C$ \\
Merge all states in $M \subseteq Q$ into any one representative of $C \subseteq Q$.

\vspace{.5cm}

For a congruence relation $\sim$, the quotient automaton is defined by state set $Q_\sim = \{ [q]_\sim \mid q \in Q\}$. \\
This is captured by the merger function $\mu_\div : Q_\sim \rightarrow 2^Q , \kappa \mapsto \kappa$.
\end{frame}




\section{Delayed Simulation}
\begin{frame}{Delayed Simulation}
\begin{defn}
	$p \equiv_\text{de} q$ iff for all $w \in \Sigma^*$, every run that starts in $\delta^*(p, w)$ or $\delta^*(q, w)$ eventually sees a priority of at most $\min \{c(\delta^*(p, w)), c(\delta^*(q, w))\}$.
\end{defn}

\begin{defn}
	Let $\mathfrak{C}_\text{de} = \{ [q]_{\equiv_\text{de}} \mid q \in Q \}$ be the set of $\equiv_\text{de}$-equivalence classes.	Define the \emph{delayed simulation merger} as $\mu_\text{de} : \mathfrak{C}_\text{de} \rightarrow 2^Q, \kappa \mapsto c^{-1}(\min c(\kappa))$.
\end{defn}

\begin{theorem}
	Merging states according to $\mu_\text{de}$ preserves language.
\end{theorem}
\end{frame}


\begin{frame}{Computing Delayed Simulation}
	We define a deterministic BÃ¼chi automaton $\mathcal{G}_\text{de}$ such that $p \equiv_\text{de} q$ iff both $L(\mathcal{G}_\text{de}, q_\text{de}^0(p, q))$ and $L(\mathcal{G}_\text{de}, q_\text{de}^0(q, p))$ are universal, i.e. $\Sigma^\omega$.
	
	This automaton uses the state set $Q_\text{de} = Q \times Q \times (c(Q) \cup \{\checkmark\})$. Computing states of universal language in a DBA requires linear time.
	
	\begin{theorem}
		$\equiv_\text{de}$ can be computed in $\mathcal{O}(n^2 k)$.
	\end{theorem}
\end{frame}

\begin{frame}{Delayed Simulation Automaton}
$\mathcal{G}_\text{de} = (Q_\text{de}, \Sigma, \delta_\text{de}, F_\text{de})$

States are $Q_\text{de} = Q \times Q \times (c(Q) \cup \{\checkmark\})$. \\
The first two components are a \enquote{simulation} of the original DPA. The third component are the so called \enquote{obligations}.

Transitions $\delta_\text{de}$. \\
The first two components mimic the transitions of $\mathcal{A}$. The third component is defined by $\gamma : Q_\text{de} \times \Sigma \rightarrow c(Q) \cup \{\checkmark\}$. (next slide)

Accepting states are $F_\text{de} = Q \times Q \times \{\checkmark\}$.

\end{frame}


\begin{frame}{Delayed Simulation Automaton: $\gamma$}
	Let $0 \leq_\checkmark 1 \leq_\checkmark 2 \leq_\checkmark \dots \leq_\checkmark \checkmark$.

	For $p, q \in Q$, $k \in c(Q) \cup \{\checkmark\}$, $a \in \Sigma$, set $\gamma((p, q, k), a) = \gamma'(\delta^*(p, a), \delta^*(q, a), k)$, where $\gamma'$ is defined as follows: \\
	If any of the following is true, then $\gamma'(i, j, k) = \checkmark$.
	
	\begin{itemize}
		\item $i$ is odd, $j$ is even, and $i \leq_\checkmark k$
		\item $i$ is odd, $j$ is even, and $j \leq_\checkmark k$
		\item $i$ is odd, $j$ is odd, $j \geq i$, and $i \leq_\checkmark k$
		\item $i$ is even, $j$ is even, $j \leq i$, and $j \leq_\checkmark k$
	\end{itemize}
	
	Otherwise, $\gamma'(i, j, k) = min_{\leq_\checkmark} \{ i,j,k \}$.
	
	$q_\text{de}^0(p, q) = (p, q, \gamma'(c(p), c(q), \checkmark))$.
\end{frame}


\begin{frame}{Delayed Simulation Automaton}
\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,initial text=]
  \node[state]           (0)                {$q_0,1$};
  \node[state]           (1) [right=of 0]   {$q_1,1$};
  \node[state]           (2) [above=of 0]   {$q_2,1$};
  \node[state]           (3) [right=of 2]   {$q_3,1$};
  \node[state]           (4) [right=of 3]   {$q_4,0$};
  \path[->] (0) edge [bend left] node [above] {a} (1)
  			(0) edge node [left] {b} (2)
            (1) edge [bend left] node [below] {a} (0)
            (1) edge node [below] {b} (4)
            (2) edge [bend left] node [above] {a,b} (3)
            (3) edge [bend left] node [below] {a} (2)
            (3) edge [bend left] node [above] {b} (4)
            (4) edge [bend left] node [below] {a,b} (3);
\end{tikzpicture}
\label{fig:examples:desim1}
\end{figure}

A DPA with 5 states. We want to check whether $q_0 \equiv_\text{de} q_1$ is true. 
\end{frame}

\begin{frame}{Delayed Simulation Automaton}
\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2.9cm,on grid,initial text=]
  \node[state,accepting] (0)			    {$q_0,q_1,\checkmark$};
  \node[state,accepting] (1) [right=of 0]   {$q_2,q_4,\checkmark$};
  \node[state,accepting] (2) [right=of 1]   {$q_3,q_3,\checkmark$};
  \node[state,accepting] (3) [below=of 0]   {$q_1,q_0,\checkmark$};
  \node[state] 			 (4) [right=of 3]   {$q_4,q_2,0$};
  \node[state] 			 (5) [right=of 4]   {$q_3,q_3,0$};
  \node[state,accepting] (6) [right=of 5]   {$q_4,q_4,\checkmark$};
  \node[state] 			 (7) [below=of 5]   {$q_2,q_2,0$};
  \node[state,accepting] (8) [right=of 2]   {$q_2,q_2,\checkmark$};
  \path[->] (0) edge node [above] {a} (1)
  			(0) edge [bend left] node [right] {b} (3)
            (1) edge node [above] {a,b} (2)
            (2) edge node [above] {a} (6)
            (2) edge [bend left] node [above] {b} (8)
            (3) edge node [above] {a} (4)
            (3) edge [bend left] node [left] {b} (0)
            (4) edge node [above] {a,b} (5)
            (5) edge [bend left] node [right] {a} (7)
            (5) edge node [above] {b} (6)
            (6) edge [bend left] node [right] {a,b} (2)
            (7) edge [bend left] node [left] {a,b} (5)
            (8) edge node [above] {a,b} (2);
\end{tikzpicture}
\caption{Example for the delayed simulation merger. (Delayed simulation game)}
\label{fig:examples:desim2}
\end{figure}
\end{frame}




\section{Congruence Path Refinement}
\begin{frame}{Congruence Path Refinement}
	\begin{defn}
	Let $\sim$ be a congruence relation and let $\lambda \subseteq Q$ be an equivalence class of $\sim$. 
	The \emph{path refinement} equivalence $\equiv_\text{PR}^\lambda$ is the smallest relation
	\end{defn}
\end{frame}





















