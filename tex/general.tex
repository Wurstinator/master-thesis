\section{General Results}
We first use this section to establish some general results that are used multiple times in the upcoming proofs.

\subsection{Equivalence Relations}

In general, we use the symbol $\equiv$ to denote equivalence relations, mostly between states of an automata. In general, we have automata $\mathcal{A}$ and $\mathcal{B}$ with states $p$ and $q$ from there respective state spaces. Our relations are then defined on $(\mathcal{A}, p) \equiv (\mathcal{B}, q)$.

\begin{defn}
	Assuming that $\mathcal{A}$ is a fixed automaton that is obvious in context and $p$ and $q$ are both states in $\mathcal{A}$, we shorten $(\mathcal{A}, p) \equiv (\mathcal{A}, q)$ to $p \equiv q$.
	
	Furthermore, we write $\mathcal{A} \equiv \mathcal{B}$ if for every $p$ in $\mathcal{A}$ there is a $q$ in $\mathcal{B}$ such that $(\mathcal{A}, p) \equiv (\mathcal{B}, q)$; and the same holds with $\mathcal{A}$ and $\mathcal{B}$ exchanged.
\end{defn}

\begin{defn}
	Let $\mathcal{A} = (Q_1, \Sigma, \delta_1)$ and $\mathcal{B} = (Q_2, \Sigma, \delta_2)$ be deterministic transition structures and let $\sim \,\subseteq (\{\mathcal{A}\} \times Q_1) \times (\{\mathcal{B}\} \times Q_2)$ be an equivalence relation. We call $R$ a \emph{congruence relation} if for all $(\mathcal{A}, p) \sim (\mathcal{B}, q)$ and all $a \in \Sigma$, also $(\mathcal{A}, \delta_1(p, a)) \sim (\mathcal{B}, \delta_2(q, a))$.
\end{defn}


\vspace{5pt}
The following is a comprehensive list of all relevant equivalence relations that we use.

\begin{itemize}
	\item Language equivalence, $\equiv_L$. Defined below.
	\item Moore equivalence, $\equiv_M$. Defined below.
	\item Priority almost equivalence, $\equiv_\text{\Ankh}$. Defined below.
	\item Delayed simulation equivalence, $\equiv_\text{de}$. Defined in %TODO
	\item Path refinement equivalence, $\equiv_\text{PR}$. Defined in %TODO
	\item Threshold Moore equivalence, $\equiv_\text{TM}$. Defined in %TODO
	\item Labeled SCC filter equivalence, $\equiv_\text{LSF}$. Defined in %TODO
\end{itemize}

Immediately we define the three first of these relations and show that they are computable.


\subsubsection{Language Equivalence}

\begin{defn}
	Let $\mathcal{A}$ and $\mathcal{B}$ be $\omega$-automata. We define \emph{language equivalence} as $(\mathcal{A}, p) \equiv_L (\mathcal{B}, q)$ if and only if for all words $\alpha \in \Sigma^\omega$, $\mathcal{A}$ accepts $\alpha$ from $p$ iff $\mathcal{B}$ accepts $\alpha$ from $q$.
\end{defn}

\begin{lem}
	$\equiv_L$ is a congruence relation.
	\label{lem:general:L_congruence}
\end{lem}

\begin{proof}
	It is obvious that $\equiv_L$ is an equivalence relation. For two states $(\mathcal{A}, p) \equiv_L (\mathcal{B}, q)$ and some successors $p' = \delta_1(p, a)$ and $q' = \delta_2(q, a)$, it must be true that $(\mathcal{A}, p') \equiv_L (\mathcal{B}, q')$. Otherwise there is a word $\alpha \in \Sigma^\omega$ that is accepted from $p'$ and rejected from $q'$ (or vice-versa). Then $a \cdot \alpha$ is rejected from $p$ and accepted from $q$ and thus $p \not\equiv_L q$.
\end{proof}

\begin{lem}
	Language equivalence of a given DPA can be computed in $\mathcal{O}(|Q|^2 \cdot |c(Q)|^2)$.
\end{lem}

\begin{proof}
	The algorithm is based partially on \cite{HenzingerTelle1996}.
	
	Let $\mathcal{A} = (Q, \Sigma, \delta, c)$ be the DPA that we want to compute $\equiv_L$ on. We construct a labeled deterministic transition structure $\mathcal{B} = (Q \times Q, \Sigma, \delta', d)$ with $\delta'((p_1, p_2), a) = (\delta(p_1, a), \delta(p_2, a))$ and $d((p_1, p_2)) = (c(p_1), c(p_2)) \in \mathbb{N}^2$. Then, for every $i, j \in c(Q)$, let $\mathcal{B}_{i,j} = \mathcal{B} \upharpoonright_{Q_{i,j}}$ with $Q_{i,j} = \{ (p_1, p_2) \in Q \times Q \mid c(p_1) \geq i, c(p_2) \geq j \}$, i.e. remove all states which have first priority less than $i$ or second priority less than $j$.
	
	For each $i$ and $j$, let $S_{i,j} \subseteq 2^{Q \times Q}$ be the set of all SCCs in $\mathcal{B}_{i,j}$ and let $S = \bigcup_{i,j} S_{i,j}$. From this set $S$, remove all SCCs $s \subseteq Q \times Q$ in which the parity of the smallest priority in the first component differs from the parity of the smallest priority in the second component. The \enquote{filtered} set we call $S'$. For any two states $p, q \in Q$, $p \not\equiv_L q$ iff there is a pair $(p', q') \in \bigcup S'$ that is reachable from $(p, q)$ in $\mathcal{B}$.
	
	We omit the correctness proof of the algorithm here. Regarding the runtime, observe that $\mathcal{B}$ has size $\mathcal{O}(|Q|^2)$ and we create $\mathcal{O}(|c(Q)|^2)$ copies of it. All other steps like computing the SCCs can then be done in linear time in the size of the automata, which brings the total to $\mathcal{O}(|Q|^2 \cdot |c(Q)|^2)$.
\end{proof}


\subsubsection{Priority Almost Equivalence}

\begin{defn}
	Let $\mathcal{A} = (Q_1, \Sigma, \delta_1, c_1)$ and $\mathcal{B} = (Q_2, \Sigma, \delta_2, c_2)$ be DPAs. We define \emph{priority almost equivalence} as $(\mathcal{A}, p) \equiv_\text{\Ankh} (\mathcal{B}, q)$ if and only if for all words $\alpha \in \Sigma^\omega$, $c_1^*(p, \alpha)$ and $c_2^*(q, \alpha)$ differ at only finitely many positions.
\end{defn}

\begin{lem}
	Priority almost equivalence is a congruence relation.
	\label{lem:general:Ankh_congruence}
\end{lem}

\begin{proof} 
	It is obvious that $\equiv_\text{\Ankh}$ is an equivalence relation. For two states $(\mathcal{A}, p) \equiv_\text{\Ankh} (\mathcal{B}, q)$ and some successors $p' = \delta(p, a)$ and $q' = \delta(q, a)$, it must be true that $(\mathcal{A}, p') \equiv_\text{\Ankh} (\mathcal{B}, q')$. Otherwise there is a word $\alpha \in \Sigma^\omega$ such that $c_1^*(p', \alpha)$ and $c_2^*(q', \alpha)$ differ at infinitely many positions. Then $c_1^*(p, a \alpha)$ and $c_2^*(q, a \alpha)$ also differ at infinitely many positions and thus $(\mathcal{A}, p) \not\equiv_\text{\Ankh} (\mathcal{B}, q)$.
\end{proof}

The following definition is used as an intermediate step on the way to computing $\equiv_\text{\Ankh}$.

\begin{defn}
	Let $\mathcal{A} = (Q_1, \Sigma, \delta_1, c_1)$ and $\mathcal{B} = (Q_2, \Sigma, \delta_2, c_2)$ be DPAs. We define the deterministic BÃ¼chi automaton $\mathcal{A} \intercal \mathcal{B} = (Q_1 \times Q_2, \Sigma, \delta_\intercal, F_\intercal)$ with $\delta_\intercal((q_1, q_2), a) = (\delta_1(q_1, a), \delta_2(q_2, a))$. The transition structure is a common product automaton.
	
	The final states are $F_\intercal = \{ (p, q) \in Q_1 \times Q_2 \mid c_1(p) \neq c_2(q) \}$, i.e. every pair of states at which the priorities differ. 
\end{defn}

\begin{lem}
	$\mathcal{A} \intercal \mathcal{B}$ can be computed in time $\mathcal{O}(|\mathcal{A}| \cdot |\mathcal{B}|)$.
	\label{lem:general:intercal_runtime}
\end{lem}

\begin{proof}
	The definition already provides a rather straightforward description of how to compute $\mathcal{A} \intercal \mathcal{B}$. Each state only requires constant time (assuming that $\delta$ and $c$ can be evaluated in such) and has $|\mathcal{A}| \cdot |\mathcal{B}|$ many states.
\end{proof}

\begin{lem}
	Let $\mathcal{A} = (Q_1, \Sigma, \delta_1, c_1)$ and $\mathcal{B} = (Q_2, \Sigma, \delta_2, c_2)$ be DPAs. $(\mathcal{A}, p) \equiv_\text{\Ankh} (\mathcal{B}, q)$ iff $L(\mathcal{A} \intercal \mathcal{B}, (p, q)) = \emptyset$. 
	\label{lem:general:intercal_prioalmostequiv}
\end{lem}

\begin{proof}
	For the first direction of implication, let $L(\mathcal{A} \intercal \mathcal{B}, (p_0, q_0)) \neq \emptyset$, so there is a word $\alpha$ accepted by that automaton. Let $(p, q) (p_1, q_1) (p_2, q_2) \cdots$ be the accepting run on $\alpha$. Then $p p_1 \cdots$ and $q q_1 \cdots$ are the runs of $\mathcal{A}$ and $\mathcal{B}$ on $\alpha$ respectively. Whenever $(p_i, q_i) \in F_\intercal$, $p_i$ and $q_i$ have different priorities. As the run of the product automaton vists infinitely many accepting states, $\alpha$ is a witness for $p$ and $q$ being not priority almost-equivalent.
	
	For the second direction, let $p$ and $q$ be not priority almost-equivalent, so there is a witness $\alpha$ at which infinitely many positions differ in priority. Analogously to the first direction, this means that the run of $\mathcal{A} \intercal \mathcal{B}$ on the same word is accepting and therefore the language is not empty.
\end{proof}

\begin{cor}
	Priority almost equivalence of a given DPA can be computed in quadratic time.
\end{cor}

\begin{proof}
	By Lemma \ref{lem:general:intercal_runtime}, we can compute $\mathcal{A} \intercal \mathcal{A}$ in quadratic time. The emptiness problem for deterministic B\"uchi automata is solvable in linear time by checking reachability of loops that contain a state in $F$. 
\end{proof}


\subsubsection{Moore Equivalence}

\begin{defn}
	Let $\mathcal{A} = (Q_1, \Sigma, \delta_1, c_1)$ and $\mathcal{B} = (Q_2, \Sigma, \delta_2, c_2)$ be DPAs. We define \emph{Moore equivalence} as $(\mathcal{A}, p) \equiv_M (\mathcal{B}, q)$ if and only if for all words $w \in \Sigma^*$, $c_1(\delta^*(p, w)) = c_2(\delta^*(q, w))$.
\end{defn}

\begin{lem}
	$\equiv_M$ is a congruence relation.
	\label{lem:general:M_congruence}
\end{lem}

\begin{proof}
	It is obvious that $\equiv_M$ is an equivalence relation. For two states $(\mathcal{A}, p) \equiv_M (\mathcal{B}, q)$ and some successors $p' = \delta(p, a)$ and $q' = \delta(q, a)$, it must be true that $(\mathcal{A}, p') \equiv_M (\mathcal{B}, q')$. Otherwise there is a word $w \in \Sigma^*$ such that $c_1(\delta_1^*(p', w)) \neq c_2(\delta_2^*(q', w))$. Then $c_1(\delta_1^*(p, aw)) \neq c_2(\delta_2^*(q, aw))$ and thus $(\mathcal{A}, p) \not\equiv_M (\mathcal{B}, q)$.
\end{proof}

\begin{lem}
	Moore equivalence of a given DPA can be computed in log-linear time.
\end{lem}

\begin{proof}
	We refer to \cite{Hopcroft1971}. The given algorithm can be adapted to Moore automata without changing the complexity.
\end{proof}


\vspace{10pt}

\begin{lem}
	$\equiv_M \,\subseteq\, \equiv_\text{\Ankh} \,\subseteq\, \equiv_L$
	\label{lem:general:M_subs_Ankh_subs_L}
\end{lem}

\begin{proof}
	Let $\mathcal{A} = (Q_\mathcal{A}, \Sigma, q_0^\mathcal{A}, \delta_\mathcal{A}, c_\mathcal{A})$ and $\mathcal{B} = (Q_\mathcal{B}, \Sigma, q_0^\mathcal{B}, \delta_\mathcal{B}, c_\mathcal{B})$ be two DPA that are priority almost-equivalent and assume towards a contradiction that they are not language equivalent. Due to symmetry we can assume that there is a $w \in L(\mathcal{A}) \setminus L(\mathcal{B})$. 
	
	Consider $\alpha = \lambda_\mathcal{A}(q_0^\mathcal{A}, w)$ and $\beta = \lambda_\mathcal{B}(q_0^\mathcal{B}, w)$, the priority outputs of the automata on $w$. By choice of $w$, we know that $a := \max \text{Inf}(\alpha)$ is even and $b := \max \text{Inf}(\beta)$ is odd. Without loss of generality, assume $a > b$. That means $a$ is seen only finitely often in $\beta$ but infinitely often in $a$. Hence, $\alpha$ and $\beta$ differ at infinitely many positions where $a$ occurs in $\alpha$. That would mean $w$ is a witness that the two automata are not priority almost-equivalent, contradicting our assumption.
	
	%TODO
\end{proof}






\subsection{Representative Merge}

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, \delta, c)$ be a DPA and let $\emptyset \neq C \subseteq M \subseteq Q$. Let $\mathcal{A}' = (Q', \Sigma, \delta', c')$ be another DPA. We call $\mathcal{A}'$ a \emph{representative merge of $\mathcal{A}$ w.r.t. $M$ by candidates $C$} if it satisfies the following:
	\begin{itemize}
		\item There is a state $r_M \in C$ such that $Q' = (Q \setminus M) \cup \{r_M\}$.
		\item $c' = c\upharpoonright_{Q'}$.
		\item Let $p \in Q'$ and $\delta(p, a) = q$. If $q \in M $, then $\delta'(p, a) = r_M$. Otherwise, $\delta'(p, a) = q$. 
	\end{itemize}
	
	We call $r_M$ the \emph{representative} of $M$ in the merge. We might omit $C$ and implicitly assume $C = M$.
\end{defn}

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, \delta, c)$ be a DPA and let $\mu : D \rightarrow (2^\mathcal{Q} \setminus \emptyset)$ be a function for some $D \subseteq 2^Q$. If all sets in $D$ are pairwise disjoint and for all $X \in D$, $\mu(X) \subseteq X$, we call $\mu$ a \emph{merger function}. 
	
	A DPA $\mathcal{A}'$ is a representative merge of $\mathcal{A}$ w.r.t. $\mu$ if there is an enumeration $X_1, \dots, X_{|D|}$ of $D$ and a sequence of automata $\mathcal{A}_0, \dots, \mathcal{A}_{|D|}$ such that $\mathcal{A}_0 = \mathcal{A}$, $\mathcal{A}_{|D|} = \mathcal{A}'$ and every $\mathcal{A}_{i+1}$ is a representative merge of $\mathcal{A}_i$ w.r.t. $X_{i+1}$ by candidates $\mu(X_{i+1})$.
\end{defn}

A common special case of this are quotient automata that are often used in state space reduction. Given a congruence relation $\sim$, the quotient automaton w.r.t. $\sim$ is equivalent to a representative merge w.r.t. $\mu : \mathfrak{C}(\sim) \rightarrow 2^Q, \kappa \mapsto \kappa$.

\begin{lem}
	Let $\mathcal{A} = (Q, \Sigma, \delta, c)$ be a DPA and let $\sim$ be an equivalence relation. A representative merge of $\mathcal{A}$ w.r.t. $\sim$ is a representative merge of $\mathcal{A}$ w.r.t. $\mu : \mathfrak{C}(\sim) \rightarrow 2^Q, \kappa \mapsto \kappa$.
\end{lem}

\vspace{5pt}

The following Lemma formally proofs that this definition actually makes sense, as building representative merges is commutative if the merge sets are disjoint.

\begin{lem}
	Let $\mathcal{A} = (Q, \Sigma, \delta, c)$ be a DPA and let $M_1, M_2 \subseteq Q$. Let $\mathcal{A}_1$ be a representative merge of $\mathcal{A}$ w.r.t. $M_1$ by some candidates $C_1$. Let $\mathcal{A}_{12}$ be a representative merge of $\mathcal{A}_1$ w.r.t. $M_2$ by some candidates $C_2$. If $M_1$ and $M_2$ are disjoint, then there is a representative merge $\mathcal{A}_2$ of $\mathcal{A}$ w.r.t. $M_2$ by candidates $C_2$ such that $\mathcal{A}_{12}$ is a representative merge of $\mathcal{A}_2$ w.r.t $M_1$ by candidates $C_1$.
\end{lem}

\begin{proof}
	By choosing the same representative $r_{M_1}$ and $r_{M_2}$ in the merges, this is a simple application of the definition.
\end{proof}

The following Lemma, while simple to prove, is interesting and will find use in multiple proofs of correctness later on.

\begin{lem}
	Let $\mathcal{A}$ be a DPA. Let $\sim$ be a congruence relation on $Q$ and let $M \subseteq Q$ such that for all $x, y \in M$, $x \sim y$. Let $\mathcal{A}'$ be a representative merge of $\mathcal{A}$ w.r.t. $M$ by candidates $C$. Let $\rho$ and $\rho'$ be runs of $\mathcal{A}$ and $\mathcal{A}'$ on some $\alpha$. Then for all $i$, $\rho(i) \equiv \rho'(i)$.
	\label{lem:general:cong_stays_in_merge}
\end{lem}

\begin{proof}
	We use a proof by induction. For $i = 0$, we have $\rho(0) = q_0$ for some $q_0 \in Q$ and $\rho'(0) = r_{[q_0]_M}$. By choice of the representative, $q_0 \in M$ and $r_{[q_0]_M} \in M$ and thus $q_0 \sim r_{[q_0]_M}$.
	
	Now consider some $i+1 > 0$. Then $\rho'(i+1) = r_{[q]_M}$ for $q = \delta(\rho'(i), \alpha(i))$. By induction we know that $\rho(i) \sim \rho'(i)$ and thus $\delta(\rho(i), \alpha(i)) = \rho(i+1) \sim q$. Further, we know $q \sim r_{[q]_M}$ by the same argument as before. Together this lets us conclude in $\rho(i+1) \sim q \sim \rho'(i+1)$.
\end{proof}

The following is a comprehensive list of all relevant merger functions that we use.

\begin{itemize}
	\item Moore merger $\mu_M$. Defined below.
	\item Skip merger, $\mu_\text{skip}^\sim$. Defined in section \ref{sect:skipper}.
\end{itemize}


\subsubsection{Moore merger}
\begin{defn}
	Let $\mathcal{A}$ be a DPA. The Moore merger $\mu_M$ is defined as $\mu_M : \mathfrak{C}(\equiv_M) \rightarrow 2^Q, \kappa \mapsto \kappa$.
\end{defn}

\begin{lem}
	Let $\mathcal{A}$ be a DPA and let $\mathcal{A}'$ be a representative merge of $\mathcal{A}$ w.r.t. $\mu_M$. Then $\mathcal{A}$ and $\mathcal{A}'$ are Moore equivalent.
	\label{lem:general:moore_merge_keeps_mooreequiv}
\end{lem}

\begin{proof}
	%TODO
\end{proof}

\begin{cor}
	Let $\mathcal{A}$ be a DPA and let $\mathcal{A}'$ be a representative merge of $\mathcal{A}$ w.r.t. $\mu_M$. Then $\mathcal{A}$ and $\mathcal{A}'$ are language equivalent.
\end{cor}





\subsection{Reachability}

\begin{defn}
	Let $\mathcal{S} = (Q, \Sigma, \delta)$ be a deterministic transition structure. We define the \emph{reachability order} $\preceq_\text{reach}^\mathcal{S}$ as $p \preceq_\text{reach}^\mathcal{S} q$ if and only if $q$ is reachable from $p$. 
\end{defn}

We want to note here that we always assume for all automata to only have one connected component, i.e. for all states $p$ and $q$, there is a state $r$ such that $p$ and $q$ are both reachable from $r$. In practice, most automata have an predefined initial state and a simple depth first search can be used to eliminate all unreachable states.

\begin{lem}
	$\preceq_\text{reach}^\mathcal{S}$ is a preorder.
\end{lem}

\begin{defn}
	Let $\mathcal{S} = (Q, \Sigma, \delta)$ be a deterministic transition structure. We call a relation $\preceq$ a \emph{total extension of reachability} if it is a minimal superset of $\preceq_\text{reach}^\mathcal{S}$ that is also a total preorder.
	
	For $p \preceq q$ and $q \preceq p$, we write $p \simeq q$.
\end{defn}

\begin{lem}
	For a given deterministic transition structure $\mathcal{S}$, a total extension of reachability is computable in $\mathcal{O}(|\mathcal{S}|)$.
	\label{lem:general:reach_topo_lintime}
\end{lem}

\begin{proof}
	Using e.g. Kosaraju's algorithm \ref{}, the SCCs of $\mathcal{A}$ can be computed in linear time. We can now build a DAG from $\mathcal{A}$ by merging all states in an SCC into a single state; iterate over all transitions $(p, a, q)$ and add an $a$-transition from the merged representative of $p$ to that of $q$. Assuming efficient data structures for the computed SCCs, this DAG can be computed in $O(|\mathcal{A}|)$ time.
	
	To finish the computation of $\preceq$, we look for a topological order on that DAG. This is a total preorder on the SCCs that is compatible with reachability. All that is left to be done is to extend that order to all states.
\end{proof}

















