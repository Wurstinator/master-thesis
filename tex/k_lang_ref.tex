
\section{Congruence Path Refinement}

In this section we present an algorithm that uses an existing congruence relation and refines it to the point where equivalent states can be \enquote{merged}.

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA and let $\equiv \,\subseteq Q \times Q$ be an equivalence relation on the state set. For every equivalence class $\kappa \subseteq Q$, let $r_\kappa \in \kappa$ be an arbitrary representative of that class. For a DPA $\mathcal{A}' = (Q', \Sigma, q'_0, \delta', c')$, we say that $\mathcal{A}'$ is a \emph{representative merge of $\mathcal{A}$ w.r.t. $\equiv$} if it satisfies the following:
	\begin{itemize}
		\item $Q' = \{ r_{[q]_\equiv} \subseteq Q \mid q \in Q \}$
		\item $q'_0 = r_{[q_0]_\equiv}$
		\item For all $q \in Q'$ and $a \in \Sigma$: $\delta'(q, a) = r_{[\delta(q, a)]_\equiv}$
		\item $c' = c\upharpoonright_{Q'}$
	\end{itemize}
\end{defn}

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA and let $R \subseteq Q \times Q$ be a congruence relation on the state space. Let $\lambda \subseteq Q$ be an equivalence class of $R$. We define $L_{\lambda \hookleftarrow}$ as the set of words $w$ such that for any $u \sqsubseteq w$, $(\delta(p, u), q) \in R$ iff $u \in \{\varepsilon, w\}$. In other words, the set contains all minimal words by which the automaton moves from $\lambda$ to $\lambda$ again.
	
	Let $f_\text{PR} : 2^{\lambda \times \lambda} \rightarrow 2^{\lambda \times \lambda}$ be a function such that $(p, q) \in f(X)$  iff for all $w \in L_{\lambda \hookleftarrow}$, $(\delta^*(p, w), \delta^*(q, w)) \in X$.
	Then let $X_0 \subseteq \lambda \times \lambda$ such that $(p, q) \in X_0$ iff for all $w \in L_{\lambda \hookleftarrow}$, $\min \{ c(\delta^*(p, u)) \mid u \sqsubset w \} = \min \{ c(\delta^*(q, u)) \mid u \sqsubset w \}$, i.e. the minimal priority when moving from $p$ or $q$ to $\lambda$ again is the same.
	
	Using both, we set $X_{i+1} = f_\text{PR}(X_i)$. $f_\text{PR}$ is monotone w.r.t. $\subseteq$, so there is an $X_n = X_{n+1}$ by Kleene's fixed point theorem. We define the \emph{path refinement of $\lambda$}, called $\equiv_\text{PR}^\lambda$, as
	\begin{itemize}
		\item For $p \in Q \setminus \lambda$, $p \equiv_\text{PR}^\lambda q$ iff $p = q$.
		\item For $p, q \in \lambda$, $p \equiv_\text{PR}^\lambda q$ iff $(p, q) \in X_n$.
	\end{itemize}
\end{defn}


\begin{theorem}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA and let $R \subseteq Q \times Q$ be a congruence relation that implies language equivalence. Let $\mathcal{A}'$ be a representative merge of $\mathcal{A}$ w.r.t. $\equiv_\text{PR}^\lambda$ for some equivalence class $\lambda$ of $R$. Then $L(\mathcal{A}) = L(\mathcal{A}')$.
\end{theorem}

\begin{proof}
	Let $\alpha \in \Sigma^\omega$ be a word with runs $\rho \in Q^\omega$ and $\rho' \in (Q')^\omega$ of $\mathcal{A}$ and $\mathcal{A}'$ respectively. Let $k_0, \dots \in \mathbb{N}$ be exactly those positions (in order) at which $\rho$ reaches $\lambda$, and analogously $k'_0, \dots$ for $\rho'$.

	\vspace{5pt}
	\textbf{Claim 1}: For every $i$, $k_i = k'_i$ and $\rho(k_i) \equiv_\text{PR}^\lambda \rho'(k_i)$.
	For all $j < k_0$, we know that $\rho(j) = \rho'(j)$, as no redirected edge is taken. Thus, $\rho'(k_0) = r_{[\rho(k_0)]_{\equiv_\text{PR}^\lambda}} \equiv_\text{PR}^\lambda = \rho(k_0)$.
	
	Now assume that the claim holds for all $i \leq n$. By definition, $w = \alpha[k_n, k_{n+1}] \in L_{\lambda \hookleftarrow}$ and therefore $\rho(k_{n+1}) = \delta^*(\rho(k_n), w) \equiv_\text{PR}^\lambda \delta^*(\rho'(k_n), w) = \rho'(k_{n+1})$.
	
	\vspace{5pt}
	\textbf{Claim 2}: If $\lambda$ only occurs finitely often in $\rho$ and $\rho'$, then $\rho$ is accepting iff $\rho'$ is accepting. 
	
	Let $k_n \in \mathbb{N}$ be the last position at which $\rho(k_n)$ and $\rho'(k_n)$ are in $\lambda$. From this point on, $\rho'[k_n, \omega]$ is also a valid run of $\mathcal{A}$ on $\alpha[k_n, \omega]$. $\rho(k_n), \rho'(k_n) \in \lambda$, so $(\rho(k_n), \rho'(k_n)) \in R$. As $R$ implies language equivalence, reading $\alpha[k_n, \omega]$ from either state in $\mathcal{A}$ leads to the same acceptance status. This also means that $\rho'(k_n)$ has the same acceptance status as $\rho(k_n)$.
	
	\vspace{5pt}
	\textbf{Claim 3}: If $\lambda$ occurs infinitely often in $\rho$ and $\rho'$, then $\rho$ is accepting iff $\rho'$ is accepting. 
	
	For each $i$, $\alpha[k_i, k_{i+1}] \in L_{\lambda \hookleftarrow}$ by choice of the $k_i$. Hence, $\min \text{Occ}(c(\rho[k_i, k_{i+1}])) = \min \text{Occ}(c'(\rho'[k_i, k_{i+1}]))$ follows directly from the definition of $\equiv_\text{PR}^\lambda$. Extending that result gives us $\min \text{Inf}(c(\rho)) = \min \text{Inf}(c'(\rho'))$. 
\end{proof}


\begin{lem}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA and let $R \subseteq Q \times Q$ be a congruence relation that implies language equivalence. Let $\mathcal{A}'$ be a representative merge of $\mathcal{A}$ w.r.t. $\equiv_\text{PR}^\lambda$ for some equivalence class $\lambda$ of $R$. Then $R \upharpoonright_{Q'}$ still is a congruence relation that implies language equivalence in $\mathcal{A}'$.
\end{lem}

\begin{proof}
	%TODO
\end{proof}


\subsection{Algorithmic Definition}
The definition of path refinement that we introduced is useful for the proofs of correctness. It however does not provide one with a way to actually compute the relation. That is why we now provide an alternative definition that yields the same results but is more algorithmic in nature.

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA and let $R \subseteq Q \times Q$ be a congruence relation. For each equivalence class $\lambda$ of $R$, we define the \emph{path refinement automaton} $\mathcal{G}_\text{PR}^{R,\lambda}(p, q) = (Q_\text{PR}, \Sigma, q_{0, \text{PR}}^{p,q}, \delta^\lambda_\text{PR}, F_\text{PR})$, which is a DFA.
	
	\begin{itemize}
		\item $Q_\text{PR} = (Q \times Q \times c(Q) \times \{<, >, =\}) \cup \{ \perp \}$
		\item $q_{0, \text{PR}}^{p,q} = (p, q, \eta_k(c(p), c(q), \checkmark), \eta_x(c(p), c(q), \checkmark, =))$
		\item $\delta^\lambda_\text{PR}((p, q, k, x), a) = \begin{cases}
			(p', q', \eta_k(c(p'), c(q'), k), \eta_x(c(p'), c(q'), k, x)) & \text{if } p' \notin \lambda \\
			q_{0,\text{PR}}^{p',q'} & \text{if } p' \in \lambda \text{ and } (x =\, =) \\
			\perp & \text{else}
		\end{cases}$ \\
			where $p' = \delta(p, a)$ and $q' = \delta(q, a)$. \\
			$\eta_k(k_p, k_q, k) = \min_{\leq_\checkmark} \{k_p, k_q, k\}$ \\
			$\eta_x(k_p, k_q, k, x) = \begin{cases}
				< & \text{if } (k_p <_\checkmark k_q \text{ and } k_p <_\checkmark k) \text{ or } (k < k_q \text{ and } (x =\, <)) \\
				> & \text{if } (k_p >_\checkmark k_q \text{ and } k >_\checkmark k_q) \text{ or } (k_p > k \text{ and } (x =\, >)) \\
				= & \text{else}
			\end{cases}$ 
		\item $F_\text{PR} = Q_\text{PR} \setminus \{\perp\}$
	\end{itemize}
\end{defn}

\begin{lem}
	Let $\mathcal{A}$ be a DPA with a congruence relation $R$. Let $\lambda$ be an equivalence class of $R$, $p, q \in \lambda$, and $w \in L_{\lambda \rightarrow \lambda}$. For every $v \sqsubset w$ and $\oplus \in \{<, >, =\}$, the fourth component of $(\delta_\text{PR}^\lambda)^*(q_{0,\text{PR}}, v)$ is $\oplus$ if and only if $\min \{ c(\delta^*(p, u)) \mid u \sqsubseteq v \} \oplus \min \{ c(\delta^*(q, u)) \mid u \sqsubseteq v \}$.
	\label{lem:pr:pr_game_nx}
\end{lem}

	The proof of this Lemma is a very formal analysis of every case in the relations between the different priorities that occur and making sure that the definition of $\eta_x$ covers these correctly. No great insight is gained, which is why we omit the proof at this point.

\begin{theorem}
	Let $\mathcal{A}$ be a DPA with a congruence relation $R$. Let $\lambda$ be an equivalence class of $R$ and $p, q \in \lambda$. Then $p \equiv_\text{PR}^R q$ iff $L(\mathcal{G}_\text{PR}^{R,\lambda}(p, q)) = \Sigma^*$.
\end{theorem}

\begin{proof}
	\textbf{If } Let $p \not\equiv_\text{PR}^R q$. Similarly to the proof of Lemma \ref{lem:pr:pr_well_def}, we use the inductive definition of $R_\kappa \subseteq\, \equiv_\text{PR}^R$ using $f$ and the sets $X_i$ here. Let $m$ be the smallest index at which $(p, q) \notin X_m$. Let $\rho = (p_i, q_i, k_i, x_i)_{0 \leq i \leq |w|}$ be the run of $\mathcal{G}_\text{PR}^{R,\lambda}(p, q)$ on $w$. We prove that $\rho(|w|) = \perp$ and therefore $\rho$ is not accepting by induction on $m$.
	
	If $m = 0$, then $(p, q) \notin Y_\lambda$, meaning that there is a word $w$ such that $\min \{ c(\delta^*(p, u)) \mid u \sqsubset w \} \neq \min \{ c(\delta^*(q, u)) \mid u \sqsubset w \}$. Without loss of generality, assume $\min \{ c(\delta^*(p, u)) \mid u \sqsubset w \} < \min \{ c(\delta^*(q, u)) \mid u \sqsubset w \}$. By Lemma \ref{lem:pr:pr_game_nx}, $x_{|w|-1} =\, <$. Furthermore, $\delta(p_{|w|-1}, w_{|w|-1}) \in \lambda$, as $w \in L_{\lambda \rightarrow \lambda}$. Thus, $\rho(|w|) =\, \perp$ and the run is rejecting.
	
	Now consider $m+1 > 1$. Since $(p, q) \in X_m \setminus f(X_m)$, there must be a word $w \in L_{\lambda \rightarrow \lambda}$ such that $(p', q') \notin X_m$, where $p' = \delta^*(p, w)$ and $q' = \delta^*(q, w)$. As $R_\kappa \subseteq X_m$, $(p', q') \notin R_\kappa$ and therefore $p' \not\equiv_\text{PR}^R q'$. By induction, $w \notin L(\mathcal{G}_\text{PR}^{R,\lambda}(p', q'))$; since that run is a suffix of $\rho$, $\rho$ itself is also a rejecting run.
	
	\paragraph{Only If} Let $L(\mathcal{G}_\text{PR}^{R,\lambda}(p, q)) \neq \Sigma^*$. Since $\varepsilon$ is always accepted, there is a word $w \in \Sigma^+ \setminus L(\mathcal{G}_\text{PR}^{R,\lambda}(p, q))$, meaning that $\delta_\text{PR}^*(q_{0,\text{PR}}, w) = \perp$. Split $w$ into sub-words $w = u_1 \cdots u_m$ such that $u_1, \dots, u_m \in L_{\lambda \rightarrow \lambda}$. Note that this partition is unique. We show $p \not\equiv_\text{PR}^R q$ by induction on $m$. Let $\rho = (p_i, q_i, k_i, x_i)_{0 \leq i < |w|}$ be the run of $\mathcal{G}_\text{PR}^{R,\lambda}(p, q)$ on $w$.
	
	If $m = 1$, then $w \in L_{\lambda \rightarrow \lambda}$. Since $\rho(|w|) =\, \perp$, it must be true that $x_{|w|-1} \neq\, =$. Without loss of generality, assume $x_{|w|-1} =\, <$. By Lemma \ref{lem:pr:pr_game_nx}, $\min \{ c(\delta^*(p, u)) \mid u \sqsubset w \} < \min \{ c(\delta^*(q, u)) \mid u \sqsubset w \}$. Therefore, $p \not\equiv_\text{PR}^R q$.
	
	Now consider $m+1 > 1$. Let $p' = \delta^*(p, u_1)$ and $q' = \delta^*(q, u_1)$. By induction on the word $u_2 \cdots u_m$, $p' \not\equiv_\text{PR}^R q'$. Since $u_1 \in L_{\lambda \rightarrow \lambda}$, that also means $p \not\equiv_\text{PR}^R q$.
\end{proof}

The differences between different $\mathcal{G}_\text{PR}^{R,\lambda}$ for different $\lambda$ are minor and the question whether the accepted language is universal boils down to a simple question of reachability. Thus, $\equiv_\text{PR}^R$ can be computed in $\mathcal{O}(|\mathcal{G}_\text{PR}^{R,\lambda}|)$ which is $\mathcal{O}(|Q|^2 \cdot |c(Q)|)$.



\subsection{Alternative Algorithmic Definition}
The computation presented in the previous section was a straight-forward description of $\equiv_\text{PR}^\lambda$ in an algorithmic way. We can reduce the complexity of that computation by taking a more indirect route, as we will see now.

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA. Let $R$ be a congruence relation on $Q$ and let $\lambda \subseteq Q$ be an equivalence class of $R$. We define a (deterministic) graph $\mathbb{A}^\lambda_\text{visit} = (Q^\lambda_\text{visit}, \Sigma, \delta^\lambda_\text{visit})$ as follows:
	
	\begin{itemize}
		\item $Q^\lambda_\text{visit} = Q \times c(Q)$
		\item $\delta^\lambda_\text{visit}((q, k), a) = \begin{cases}
			(\delta(q, a), \min \{k, c(q)\}) & \text{if } q \notin \lambda \\
			(\delta(q, a), c(q)) & \text{else} 
		\end{cases}$
	\end{itemize}
\end{defn}

Similar as is done in the definition of the path refinement relation, this automaton uses its second component to \enquote{memorize} the lowest priority seen on a run from $\lambda$ back into $\lambda$. 

\begin{defn}
	Consider $\mathbb{A}^\lambda_\text{visit}$ of a DPA $\mathcal{A}$ and a congruence relation $R$. We define an equivalence relation $V \subseteq Q^\lambda_\text{visit} \times Q^\lambda_\text{visit}$ as:
	\begin{itemize}
		\item For every $p, q \in Q \setminus \lambda$ and $l, k \in c(Q)$, $((p, l), (q, k)) \in V$.
		\item For every $p, q \in \lambda$, $((p, l), (q, k)) \in V$ iff $l = k$.
	\end{itemize}
	
	The Moore-refinement of $V$ is then called $V_M$.
\end{defn}

\begin{theorem}
	Let $\mathcal{A}$, $R$, and $\lambda$ be as before. For $p, q \in \lambda$, we have $p \equiv_\text{PR}^\lambda q$ iff $((p, \max c(Q)), (q, \max c(Q))) \in V_M$.
\end{theorem}

\begin{proof}
	%TODO
\end{proof}

Constructing $\mathcal{A}^\lambda_\text{visit}$ and $V$ requires time $\mathcal{O}(nk)$ and the computation of $V_M$ brings it up to $\mathcal{O}(nk \log(nk))$, where $n = |Q|$ and $k = |c(Q)|$.



















