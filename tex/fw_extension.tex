
\subsection{Alternative computation}
As we have seen, using delayed simulation to build a quotient automaton delivers good results in the number of removed states. The downside is the computation time which is much higher than that of our approach in section \ref{}. In the following we will consider alternations to the delayed simulation algorithm with the goal to increase the number of removed states or to reduce computation time.

\subsubsection{Resetting obligations}
In the delayed simulation automaton, \enquote{obligations} correspond to good priorities that the first state has accumulated or bad priorities that the second state has accumulated and the need for the respective other state to compensate in some way. The intuitive idea behind this concept is that an obligation that cannot be compensated, stands for an infinite run in which the acceptance differs between the two states that are being compared. The issue with the original definition is that obligations carry over, even if they can only be caused finitely often. This is demonstrated in figure \ref{fig:fwe:reset_oblig_example}; the two states could be merged into one, but they are not $\equiv_\text{de}$-equivalent as can be seen in the delayed simulation automaton in figure \ref{fig:fwe:reset_oblig_example_dea}.

\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,initial text=]
  \node[state,initial]   (0)                {0};
  \node[state]           (1) [right=of 0] {1};
  \path[->] (0) edge node [above] {a} (1)
            (1) edge [loop right] node {a} (1);
\end{tikzpicture}
\caption{Example automaton in which the states could be merged but delayed simulation separates them.}
\label{fig:fwe:reset_oblig_example}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,initial text=]
  \node[state]   (0)                {$0,1,0$};
  \node[state]   (1) [right=of 0] {$1,1,0$};
  \path[->] (0) edge node [above] {a} (1)
            (1) edge [loop right] node {a} (1);
\end{tikzpicture}
\caption{Example automaton in which the states could be merged but delayed simulation separates them.}
\label{fig:fwe:reset_oblig_example_dea}
\end{figure}

As a solution to this, we propose a simple change to the definition of the automaton which resets the obligations every time, either state moves to a new SCC. 

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA. We define the \emph{delayed simulation automaton with SCC resets} $\mathcal{A}_\text{deR}(p, q) = (Q_\text{de}, \Sigma, (p, q, \gamma(c(p), c(q), \checkmark), \delta_\text{deR}, F_\text{de})$ with $\delta_\text{deR}((p, q, k), a) = \delta_\text{de}((p, q, \text{reset}(p, q, k, a)), a)$. Except for the addition of the reset function, this automaton is the same as $\mathcal{A}_\text{de}$.
	
	If $p$ and $\delta(p, a)$ lie in the same SCC, as well as $q$ and $\delta(q, a)$, then we simply set $\text{reset}(p, q, k, a) =~k$. Otherwise, i.e. if any state changes its SCC, the reset comes into play and we set $\text{reset}(p, q, k, a) =~\checkmark$.
	
	We write $p \leq_\text{deR} q$ if $L(\mathcal{A}_\text{deR}(p, q)) = \Sigma^\omega$. If also $q \leq_\text{deR} p$ holds, we write $p \equiv_\text{deR} q$.
\end{defn}

As the definition is so similar to the original delayed simulation, most results that we have already proven translate directly to the new relation.

\begin{theorem}
	$\equiv_\text{deR}$ is a congruence relation.
\end{theorem}
%TODO

\begin{lem}
	Let $\mathcal{A}$ be a DPA with two states $p$ and $q$. If $p \leq_\text{de} q$, then $p \leq_\text{deR} q$.
\end{lem}
%TODO

The real difference comes up when looking at theorem \ref{thm:fritzwilke:combine_priorities}. If we consider again the example given in figure \ref{fig:fwe:reset_oblig_example}, if that theorem would hold the same for $\equiv_\text{deR}$ we could assign both states the priority $0$, which would then make the automaton accept every word. This is obviously not the same as the original automaton, so this statement deserves some additional inspection.
%TODO









\begin{lem}
\label{lem:fwe:preceq_alternative}
	Let $\mathcal{A}$ be a DPA with states $p, q \in Q$. Then $p \preceq_\text{de} q$ if and only if the following property holds for all $w \in \Sigma^*$: 
	
	Let $p' = \delta^*(p, w)$ and $q' = \delta^*(q, w)$. If $c(p')$ is even and $c(p') < c(q')$, then every path from $q'$ eventually reaches a priority at most $c(p')$. On the other hand, if $c(q')$ is odd and $c(q') < c(p')$, then every path from $p'$ eventually reaches a priority at most $c(q')$.
\end{lem}

\begin{proof}
	\textbf{If} We show the contrapositive. Let $p \not\preceq_\text{de} q$, so there is a word $\alpha \notin L(\mathcal{A}_\text{de}(p, q))$ with the run of $\mathcal{A}_\text{de}(p, q)$ being $(p_0, q_0, k_0) (p_1, q_1, k_1) \dots$. By Lemma \ref{lem:fritzwilke:n0_exists}, there is a position $n$ such that $k_i$ does not change anymore for $i \geq n$. We define $w = \alpha[0, n_0]$ and $\beta = \alpha[n_0+1, ]$ (so $\alpha = w\beta$) and claim that $w$ is a valid counterexample for the right-side property.
	
	The first case is: $c(p') < c(q')$ and $c(p')$ is even. \\
	Reading $\beta$ from $q'$ induces a run that never visits a priority less or equal to $c(p')$: Let $u \sqsubset \beta$ and assume that $c(\delta^*(q', u)) \leq c(p')$. By choice of $n$, we know that $k_{|wu|} = k_{|wu|+1} \neq \checkmark$. This can only happen if the \enquote{else} case of $\gamma$ is hit, meaning that $k_{|wu|+1} = \min \{ k_{|wu|}, c(\delta^*(p', u)), c(\delta^*(q', u)) \}$. Specifically, $c(\delta^*(q', u)) \geq k_{|wu|}$. By choice of $w$ we also have $k_{|wu|} = k_{|w|} \leq c(p')$, so $c(\delta^*(q', u)) = c(p')$.
	
	This, however, means that $c(\delta^*(q', u))$ is even, $c(\delta^*(q', u)) \leq_\checkmark k_{|wu|}$, and $c(\delta^*(q', u)) \preceq_p c(p')$ and thus $k_{|wu|+1} = \checkmark$ which is a contradiction.
	
	The second case, $c(q') < c(p')$ and $c(q')$ is odd, works almost identically so we omit the proof here.
	
	\paragraph{Only If} Again we show the contrapositive: There is a $w \in \Sigma^*$ such that the right-side property is violated. Let this $w$ now be chosen among all these words such that $\min \{ c(p'), c(q') \}$ becomes minimal. We now show that $p \not\preceq_\text{de} q$. 
	
	The first case is: $c(p') < c(q')$ and $c(p')$ is even. \\
	Let $\beta \in \Sigma^\omega$ be a word such that the respective run from $q'$ only sees priorities strictly greater than $c(p')$. Let $(p_0, q_0, k_0) (p_1, q_1, k_1) \dots$ be the run of $\mathcal{A}_\text{de}(p, q)$ on $\alpha = w \beta$. We claim that $k_i \neq \checkmark$ for all $i > |w|$. If that is true, then the run is rejecting and $\alpha \notin L(\mathcal{A}_\text{de}(p, q))$.
	
	Assume towards a contradiction that $k_i$ does become $\checkmark$ again at some point. Let $j \geq |w|$ be the minimal position with $k_{j+1} = \checkmark$. Then by definition of $\gamma$, $c(q_{j+1}) \leq k_j$ is even or $c(p_{j+1}) \leq k_j$ is odd. In the former case, we would have a contradiction to the choice of $\beta$. In the latter case, we would have a contradiction to the choice of $w$ as a word with minimal priority at $c(p')$: since $c(p')$ is even, $c(p_{j+1}) < c(p')$ and from $q_{j+1}$ there is a run that never reaches a smaller priority. Hence, $w \cdot \beta[0, j-|w|]$ would have been our choice for $w$ instead.
	
	The second case, $c(q') < c(p')$ and $c(q')$ is odd, works almost identically so we omit the proof here.
\end{proof}

While this characterization of $\preceq_\text{de}$ seems arbitrary, it allows for an easier definition of $\equiv_\text{de}$ as is seen in the following statement.

\begin{cor}
\label{cor:fwe:equivde_alternative}
	Let $\mathcal{A}$ be a DPA with states $p, q \in Q$. Then $p \equiv_\text{de} q$ if and only if the following holds for all words $w \in \Sigma^*$:
	
	Let $p' = \delta^*(p, w)$ and $q' = \delta^*(q, w)$. Every run that starts in $p'$ or $q'$ eventually sees a priority less than or equal to $\min \{c(p'), c(q')\}$.
\end{cor}

This intermediate result now easily gives us the following relation of delayed simulation and Moore-equivalence.

\begin{defn}
	Let $\mathcal{A} = (Q, \Sigma, \delta, q_0, c)$ be a parity automaton. We call $c$ \emph{normalized} if for every state $q \in Q$ that does not lie in a trivial SCC and all priorities $k \leq c(q)$, there is a path from $q$ to $q$ such that the lowest priority visited is $k$.
\end{defn}

\begin{lem}
	Let $\mathcal{A}$ be a DPA with a normalized priority function and let $p$ and $q$ be states that do not lie in trivial SCCs. Then $p \equiv_\text{de} q$ if and only if $p \sim_M q$.
\end{lem}

\begin{proof}
	The \enquote{if}-implication was shown in \ref{}. For the other direction, let $p \not\sim_M q$, so there is a word $w \in \Sigma^*$ such that $c(p') \neq c(q')$, where $p' = \delta^*(p, w)$ and $q' = \delta^*(q, w)$. Without loss of generality, assume $c(p') < c(q')$.
	
	As $c$ is normalized, there is a word $u$ such that $q'$ reaches again $q'$ via $u$ and sees only priorities greater or equal to $c(q')$. That means that on the path that is obtained from $q'$ by reading $u^\omega$, the priority $c(p')$ is never visited. By corollary \ref{cor:fwe:equivde_alternative}, that means $p \not\equiv_\text{de} q$.
\end{proof}

\subsubsection{Computing a normalized priority function}
If we can assure that our priority function is normalized, Moore-equivalence is a nice approximation of delayed simulation-equivalence. In fact, \cite{} provides an algorithm that is suited for these needs. We will briefly reiterate that algorithm here, as the original paper puts the focus on a different aspect.

\begin{algorithm}
  \caption{Normalizing the priority function of a DPA.}
  \label{alg:fwe:normalize_c}
  \begin{algorithmic}[1]
    \Function{Normalize}{$\mathcal{A}$}
  	  \Ensure{$c_N$ is normalized in $\mathcal{A}$.}
      \State $c_D \gets $\Call{MakeDense}{$\mathcal{A}$}
      \State $c_N : Q \rightarrow \mathbb{N}, q \mapsto c_D(q)$
      \State $Q' \gets Q$
      \State $k \gets 0$
      \While{$Q' \neq \emptyset$}
        \State $Q' \gets Q' \setminus c_D^{-1}(k)$
        \State $S \gets $ Trivial SCCs of $\mathcal{A}\upharpoonright_{Q'}$
        \For{$q \in S$}
          \State $c_N(q) \gets k$
        \EndFor
        \State $Q' \gets Q' \setminus S$
        \State $k \gets k+1$
      \EndWhile
      \State \Return{$c_N$}
    \EndFunction
    \Statex
    \Function{MakeDense}{$\mathcal{A}$}
      \Ensure{For all $0 \leq i \leq \max c(Q)$, $c_D^{-1}(i) \neq \emptyset$}.
      \State $c_D : Q \rightarrow \mathbb{N}, q \mapsto c(q)$
      \For{$i \gets 0 \textrm{ to } \max c(Q)$}
        \While{$c_D^{-1}(i+1) = \emptyset$}
          \For{$q \in Q : c_D(q) > i$}
            \State $c_D(q) \gets c_D(q) - 2$
          \EndFor
        \EndWhile
      \EndFor
      \State \Return{$c_D$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{lem}
	The \textsc{Normalize} function in algorithm \ref{alg:fwe:normalize_c} returns a normalized priority function for $\mathcal{A}$ that does not change the language.
\end{lem}

\begin{proof}
	The fact that the language does not change after running \textsc{Normalize} is part of the original paper.
	
	To see that $c_N$ is normalized, assume towards a contradiction that it is not. Let $c$
\end{proof}


\begin{lem}
	The \textsc{Normalize} function in algorithm \ref{alg:fwe:normalize_c} runs in $\mathcal{O}(nk)$, where $n$ is the number of states and $k$ is the number of priorities.
\end{lem}



\subsubsection{Alternative delayed simulation}

\begin{algorithm}
  \caption{Compute $\equiv_\text{de}$ of a DPA $\mathcal{A}$.}
  \label{alg:fwe:equiv_de_alt}
  \begin{algorithmic}[1]
    \Function{DelayedSimulation}{$\mathcal{A}$}
      \State $\mathcal{S} \gets$ compute SCCs of $\mathcal{A}$
      \State $\mathcal{B} \gets (\emptyset, \Sigma, 0, \emptyset, \emptyset)$
      \While{$\mathcal{S} \neq \emptyset$}
        \State $s \in \mathcal{S}$ s.t. $s$ can reach no other SCC in $\mathcal{S}$
        \State $\mathcal{B} \gets$ \Call{AddSCC}{$\mathcal{A}$, $\mathcal{B}$, $s$}
        \State $\mathcal{S} \gets \mathcal{S} \setminus s$
      \EndWhile
      \State \Return{$c_\mathcal{B}$}
    \EndFunction
    \Statex
    \Function{AddSCC}{$\mathcal{A}$, $\mathcal{B}$, $s$}
      \State $q_0 \in s$ arbitrary
      \State Add $s$ to $\mathcal{B}$: $\mathcal{B} \gets (Q \cup s, \Sigma, q_0, \delta_\mathcal{B} \cup \delta_\mathcal{A}\upharpoonright_{s \times \Sigma}, c_\mathcal{B} \cup c_\mathcal{A}\upharpoonright_s)$
      \State $\sim_M \; \gets$ Moore-equivalence of $\mathcal{B}$
      \State $\mathcal{C} \gets \bigslant{\mathcal{B}}{\sim_M}$
      \If{$q_0$ is a trivial SCC in $\mathcal{A}$ and is not $\sim_M$-equivalent to any other states}
        \If{There is a state $p \in \mathcal{C}$ such that $\forall a: \delta_\mathcal{B}(q_0, a) = \delta_\mathcal{B}(p, a)$}
          \State $c_\mathcal{B}(q_0) \gets c_\mathcal{C}(p)$
        \EndIf
      \EndIf
      \State \Return{$\mathcal{B}$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}


\begin{theorem}
	Let $\mathcal{A} = (Q, \Sigma, q_0, \delta, c)$ be a DPA s.t. $c$ is normalized and $\mathcal{A}$ contains no unreachable states. Let $c' = \textsc{DelayedSimulation}(\mathcal{A})$. Then The delayed simulation-equivalence of $\mathcal{A}$ is the same as the Moore-equivalence of $(Q, \Sigma, q_0, \delta, c')$.
\end{theorem}

\begin{proof}
	Let $s_0, \dots, s_m$ be the sequence of SCCs as they are chosen in line 5 of the algorithm and let $\mathcal{B}_0, \dots, \mathcal{B}_{m+1}$ be the sequence of automata that are set in lines 3 and 6. The computation of $\equiv_\text{de}$ and $\sim_M$ is independent of the initial state of an automaton and the state set and transition function of $\mathcal{A}$ and $\mathcal{B}_{m+1}$ are the same. It thus suffices to show that for every $0 \leq i \leq m+1$, the Moore-equivalence of $\mathcal{B}_i$ is the same as the delayed-simulation equivalence of $\mathcal{A} \upharpoonright_{Q(\mathcal{B}_i)}$.
	
	For $i = 0$, this is clear, as $Q(\mathcal{B}_0) = \emptyset$.
\end{proof}

























